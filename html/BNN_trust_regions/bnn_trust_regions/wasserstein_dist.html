<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>BNN_trust_regions.bnn_trust_regions.wasserstein_dist API documentation</title>
<meta name="description" content="This module contains functions to calculate the Wasserstein distance between two distributions." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>BNN_trust_regions.bnn_trust_regions.wasserstein_dist</code></h1>
</header>
<section id="section-intro">
<p>This module contains functions to calculate the Wasserstein distance between two distributions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; This module contains functions to calculate the Wasserstein distance between two distributions. &#34;&#34;&#34;
import typing

import joblib
import numpy as np
import ot
import scipy.stats

from tqdm import tqdm

from .gaussian import UnivariateGaussian


class WassersteinDistance:
    &#34;&#34;&#34;
    # The class WassersteinDistance calculates the Wasserstein distance between two sets of predictions
    # using the specified p-norm and parallel computing options.
    &#34;&#34;&#34;

    def __init__(self,
                 p_norm: int = 1,
                 parallel_computing: bool = False,
                 verbose: bool = False):
        &#34;&#34;&#34;
        The function initializes an object with two sets of predictions, a p-norm value, a flag for
        parallel computing, and a flag for verbosity.

        :param predictions_a: The parameter `predictions_a` is used to pass the predictions for dataset
        A. It can be either a numpy array or an instance of the `UnivariateGaussian` class
        :type predictions_a: typing.Union[np.ndarray, UnivariateGaussian]
        :param predictions_b: The `predictions_b` parameter is used to pass the predictions for the
        second set of data. It can be either a numpy array or an instance of the `UnivariateGaussian`
        class
        :type predictions_b: typing.Union[np.ndarray, UnivariateGaussian]
        :param p_norm: The p_norm parameter is an integer that specifies the norm to be used for
        calculating the distance between the predictions. It is used in the calculation of the distance
        between two predictions, where the distance is calculated as the p-norm of the difference
        between the two predictions. The p-norm is a general, defaults to 1
        :type p_norm: int (optional)
        :param parallel_computing: The `parallel_computing` parameter is a boolean flag that indicates
        whether or not to use parallel computing for the calculations. If set to `True`, the
        calculations will be performed in parallel, which can potentially speed up the computation time.
        If set to `False`, the calculations will be performed sequentially, defaults to False
        :type parallel_computing: bool (optional)
        :param verbose: The `verbose` parameter is a boolean flag that determines whether or not to
        print additional information during the execution of the code. If `verbose` is set to `True`,
        then additional information will be printed. If `verbose` is set to `False`, then no additional
        information will be printed, defaults to False
        :type verbose: bool (optional)
        &#34;&#34;&#34;
        self.p_norm = p_norm
        self.parallel_computing = parallel_computing
        self.verbose = verbose

    def calc_wasserstein_distance(self, predictions_a: typing.Union[np.ndarray, UnivariateGaussian],
                                  predictions_b: typing.Union[np.ndarray, UnivariateGaussian],):
        &#34;&#34;&#34;
        The function calculates the Wasserstein distance between two sets of predictions.
        :return: the result of the `wasserstein_univariate_wrapper` function, which calculates the
        Wasserstein distance between `self.predictions_a` and `self.predictions_b`.
        &#34;&#34;&#34;
        return wasserstein_univariate_wrapper(predictions_a, predictions_b,
                                              p_norm=self.p_norm,
                                              parallel_computing=self.parallel_computing,
                                              verbose=self.verbose)


def wasserstein_univariate_wrapper(pred_a: typing.Union[np.ndarray, UnivariateGaussian],
                                   pred_b: typing.Union[np.ndarray, UnivariateGaussian],
                                   p_norm: int = 1,
                                   parallel_computing: bool = False,
                                   verbose: bool = False):
    &#34;&#34;&#34;
    The function calculates the Wasserstein distance between two univariate distributions.

    &#34;&#34;&#34;

    # distance between two univariate gaussians
    if isinstance(pred_a, UnivariateGaussian) and isinstance(pred_b, UnivariateGaussian):
        # this is the analytical solution for the 1-Wasserstein distance between two univariate Gaussians
        if p_norm == 1:
            return wasserstein_p1_univariate_gaussian_gaussian(pred_a.mean, pred_a.var, pred_b.mean, pred_b.var)

        if p_norm == 2:
            raise NotImplementedError(
                &#34;The 2-Wasserstein distance between two univariate Gaussians is not implemented.&#34;)

        raise ValueError(
            &#34;The p-norm must be either 1 or 2 for the Wasserstein distance between two univariate Gaussians.&#34;)

    # distance between a univariate gaussian and a dirac mixture
    if isinstance(pred_a, UnivariateGaussian) and isinstance(pred_b, np.ndarray):
        return wasserstein_univariate_gaussian_dirac_multiple_distances(
            pred_b, pred_a.mean, pred_a.var, p_norm=p_norm, parallel_computing=parallel_computing, verbose=verbose)

    # distance between a dirac mixture and a univariate gaussian
    if isinstance(pred_a, np.ndarray) and isinstance(pred_b, UnivariateGaussian):
        return wasserstein_univariate_gaussian_dirac_multiple_distances(
            pred_a, pred_b.mean, pred_b.var, p_norm=p_norm, parallel_computing=parallel_computing, verbose=verbose)

    # distance between two dirac mixtures
    if isinstance(pred_a, np.ndarray) and isinstance(pred_b, np.ndarray):
        return wasserstein_optimal_transport(pred_a, pred_b, p_norm=p_norm, parallel_computing=parallel_computing, verbose=verbose)

    raise ValueError(
        &#34;The input parameters must be either a numpy array or an instance of the Gaussian class.&#34;)


def wasserstein_optimal_transport(samples1: np.ndarray,  # n_samples x n_distributions

                                  samples2: np.ndarray,  # m_samples x n_distributions
                                  weights1: np.ndarray = None,  # weight per sample
                                  weights2: np.ndarray = None,  # weight per sample
                                  p_norm: int = 1,  # p-norm
                                  parallel_computing: bool = False,  # parallel computation
                                  verbose: bool = False):  # verbose
    &#34;&#34;&#34;
    The function `wasserstein_optimal_transport` computes the Wasserstein Optimal Transport distance
    between two sets of samples.

    :param samples1: An array of shape (n_samples, n_distributions) representing the first set of
    samples. Each row corresponds to a sample, and each column corresponds to a distribution
    :type samples1: np.ndarray
    :param samples2: Array of shape (m_samples, n_distributions) representing the second set of samples
    :type samples2: np.ndarray
    :param weights1: Array of shape (n_samples,) representing the weights for each sample in samples1.
    These weights determine the importance of each sample in the computation of the Wasserstein Optimal
    Transport distance. If not provided, equal weights are assigned to each sample
    :type weights1: np.ndarray
    :param weights2: The `weights2` parameter is an optional array of shape (m_samples,) representing
    the weights for each sample in `samples2`. These weights are used to compute the Wasserstein Optimal
    Transport distance between the two sets of samples. If `weights2` is not provided, it defaults to an
    :type weights2: np.ndarray
    :param p_norm: The parameter `p_norm` is the p-norm to be used in the computation of the Wasserstein
    Optimal Transport distance. It determines the distance metric used to measure the discrepancy
    between the distributions. The default value is 1, which corresponds to the Earth Mover&#39;s distance.
    Other common choices, defaults to 1
    :type p_norm: int (optional)
    :param parallel_computing: The `parallel_computing` parameter is a boolean flag indicating whether
    to use parallel computation or not. If set to `True`, the function will use parallel computation to
    speed up the computation of the Wasserstein Optimal Transport distance. If set to `False`, the
    function will use a single thread, defaults to False
    :type parallel_computing: bool (optional)
    :param verbose: The `verbose` parameter is a boolean flag indicating whether to display progress
    information during the computation. If set to `True`, it will display progress information; if set
    to `False`, it will not display any progress information, defaults to False
    :type verbose: bool (optional)
    :return: an array of shape (n_distributions,) containing the Wasserstein Optimal Transport distance
    for each distribution.
    &#34;&#34;&#34;

    _, num_distributions = samples1.shape
    # parallel execution of statistical test
    if weights1 is None:
        weights1 = np.ones(samples1.shape[0]) / samples1.shape[0]
    if weights2 is None:
        weights2 = np.ones(samples2.shape[0]) / samples2.shape[0]

    if parallel_computing:
        n_jobs = -2
    else:
        n_jobs = 1

    wd = joblib.Parallel(n_jobs=n_jobs, verbose=0)(
        joblib.delayed(earth_mover_distance)(samples1[:, i], samples2[:, i],
                                             weights1, weights2, p_norm) for i in tqdm(range(0, num_distributions), disable=not verbose))

    return np.asarray(wd)


def earth_mover_distance(sample1: np.ndarray, sample2: np.ndarray,
                         weights_sample1: np.ndarray, weights_sample2: np.ndarray,
                         p_norm: int = 1):
    &#34;&#34;&#34;
    Compute the Earth Mover&#39;s Distance (EMD) between two samples.

    :param sample1: The first sample as a numpy array.
    :param sample2: The second sample as a numpy array.
    :param weights_sample1: The weights associated with the elements in sample1 as a numpy array.
    :param weights_sample2: The weights associated with the elements in sample2 as a numpy array.
    :param p_norm: The p-norm to be used in the computation of the EMD. Default is 1.

    :return: The Earth Mover&#39;s Distance between the two samples.
    &#34;&#34;&#34;
    return ot.emd2_1d(sample1, sample2, a=weights_sample1, b=weights_sample2,
                      metric=&#34;minkowski&#34;, p=p_norm)  # direct computation of OT loss


def wasserstein_univariate_gaussian_dirac_multiple_distances(samples: np.ndarray,
                                                             mean1: np.ndarray, var1: np.ndarray,
                                                             p_norm: int = 1,
                                                             parallel_computing: bool = False,
                                                             verbose: bool = False):
    &#34;&#34;&#34;
    The function calculates the Wasserstein distance between n=`num_distributions` univariate Gaussian and Dirac mixture
    distributions.

    :param samples: The `samples` parameter is a numpy array containing the samples from a univariate
    distribution. Each row of the array represents a different sample, and each column
    represents a different distribution. The shape of the array should be (n_samples, num_distributions),
    :type samples: np.ndarray
    :param mean1: The parameter `mean1` represents the mean of a univariate Gaussian distribution
    :type mean1: np.ndarray
    :param var1: The parameter `var1` represents the variance of a univariate Gaussian distribution
    :type var1: np.ndarray
    :param verbose: The `verbose` parameter is a boolean flag that determines whether or not to display
    progress information during the computation. If `verbose` is set to `True`, progress information
    will be displayed. If `verbose` is set to `False`, progress information will be hidden, defaults to
    False
    :type verbose: bool (optional)
    :return: an array of Wasserstein distances between the given samples and the ground truth
    distribution.
    &#34;&#34;&#34;
    _, num_distributions = samples.shape
    wd_1 = np.empty((num_distributions,))
    # for i in tqdm(range(0, num_distributions), desc=&#34;W1(Gaussian, Dirac mixture)&#34;, disable=not verbose):
    #     wd_1[i] = gaussian_dirac_mixture_wasserstein(
    #         samples=samples[:, i], mean=mean1[i], var=var1[i], p_norm=p_norm)

    if parallel_computing:
        n_jobs = -2
    else:
        n_jobs = 1

    wd_1 = joblib.Parallel(n_jobs=n_jobs, verbose=0)(
        joblib.delayed(
            wasserstein_univariate_gaussian_dirac_mixture)(samples[:, i],
                                                           mean1[i],
                                                           var1[i],
                                                           p_norm) for i in tqdm(range(0, num_distributions), disable=not verbose))
    wd_1 = np.asarray(wd_1)
    return wd_1


def wasserstein_univariate_gaussian_dirac_mixture(samples: np.ndarray, mean: float, var: float, p_norm: int = 1):
    &#34;&#34;&#34;
    Calculate the Wasserstein distance between a Gaussian distribution and a Dirac mixture.
    Use only to calculate between one Gaussian and one Dirac mixture.
    To calculate multiple distances, use `wasserstein_p1_univariate_gaussian_dirac_multiple_distances`.

    :param samples: The samples from the Dirac mixture.
    :type samples: numpy.ndarray (n_samples, 1)
    :param mean: The mean of the Gaussian distribution.
    :type mean: float
    :param var: The variance of the Gaussian distribution.
    :type var: float
    :param p_norm: The p-norm used in the Wasserstein distance calculation. Default is 1.
    :type p_norm: int, optional

    :return: The Wasserstein distance between the Gaussian distribution and the Dirac mixture.
    :rtype: float
    &#34;&#34;&#34;
    sorted_samples = np.sort(samples)
    num_samples = sorted_samples.shape[0]
    empirical_cdf = (np.arange(num_samples)+1) / (num_samples)
    mid_points_ecdf = empirical_cdf - 1/(2 * num_samples)
    gaussian_sample_positions = scipy.stats.norm.ppf(mid_points_ecdf, loc=mean, scale=np.sqrt(var))
    norm = np.power(np.abs(gaussian_sample_positions - sorted_samples), p_norm)
    wasserstein_dist = np.mean(norm)
    return wasserstein_dist


def wasserstein_p1_univariate_gaussian_gaussian(mean1: typing.Union[float, np.ndarray], var1: typing.Union[float, np.ndarray],
                                                mean2: typing.Union[float, np.ndarray], var2: typing.Union[float, np.ndarray],):
    &#34;&#34;&#34;
    The function calculates the 1-Wasserstein distance between two univariate Gaussian distributions.

    :param mean1: The mean of the first Gaussian distribution
    :type mean1: typing.Union[float, np.ndarray]
    :param var1: The variable `var1` represents the variance of the first Gaussian distribution
    :type var1: typing.Union[float, np.ndarray]
    :param mean2: The parameter `mean2` represents the mean of the second Gaussian distribution
    :type mean2: typing.Union[float, np.ndarray]
    :param var2: The parameter `var2` represents the variance of the second Gaussian distribution
    :type var2: typing.Union[float, np.ndarray]
    :return: the 1-Wasserstein distance between two univariate Gaussian distributions.
    :rtype: np.ndarray
    &#34;&#34;&#34;
    # calculate 1-wasserstein distance between two gaussians
    # On the 1-Wasserstein Distance between Location-Scale Distributions and the Effect of Differential Privacy
    # Saurab Chhachhi, Fei Teng
    # https://doi.org/10.48550/arXiv.2304.14869 equation (34)

    # flatten arrays
    mean1 = np.ravel(mean1)
    mean2 = np.ravel(mean2)
    var1 = np.ravel(var1)
    var2 = np.ravel(var2)

    mean_y = mean1 - mean2
    cov_y = np.square(np.sqrt(var1) - np.sqrt(var2))
    mean_y_abs = np.abs(mean_y)
    std_y_abs = np.abs(np.sqrt(cov_y))
    factor1 = mean_y_abs

    factor2 = np.empty_like(mean_y_abs)
    factor4 = np.empty_like(mean_y_abs)

    where_std_y_zero = std_y_abs == 0
    non_zero = np.logical_not(where_std_y_zero)

    if np.sum(non_zero) &gt; 0:
        factor2[non_zero] = 1 - 2 * \
            scipy.stats.norm.cdf(-mean_y_abs[non_zero] / std_y_abs[non_zero])
        factor4[non_zero] = np.exp(-np.square(mean_y_abs) / (2 * cov_y[non_zero]))

    if np.sum(where_std_y_zero) &gt; 0:
        # limit of factor1 for cov_y -&gt; 0 is 1; see paper
        factor2[where_std_y_zero] = 1

        # limit of factor4 for cov_y -&gt; 0 is 1; see paper
        factor4[where_std_y_zero] = np.ones_like(factor4[where_std_y_zero])

    factor3 = std_y_abs * np.sqrt(2 / np.pi)

    term1 = factor1 * factor2
    term2 = factor3 * factor4

    return term1 + term2</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.earth_mover_distance"><code class="name flex">
<span>def <span class="ident">earth_mover_distance</span></span>(<span>sample1: numpy.ndarray, sample2: numpy.ndarray, weights_sample1: numpy.ndarray, weights_sample2: numpy.ndarray, p_norm: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Earth Mover's Distance (EMD) between two samples.</p>
<p>:param sample1: The first sample as a numpy array.
:param sample2: The second sample as a numpy array.
:param weights_sample1: The weights associated with the elements in sample1 as a numpy array.
:param weights_sample2: The weights associated with the elements in sample2 as a numpy array.
:param p_norm: The p-norm to be used in the computation of the EMD. Default is 1.</p>
<p>:return: The Earth Mover's Distance between the two samples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def earth_mover_distance(sample1: np.ndarray, sample2: np.ndarray,
                         weights_sample1: np.ndarray, weights_sample2: np.ndarray,
                         p_norm: int = 1):
    &#34;&#34;&#34;
    Compute the Earth Mover&#39;s Distance (EMD) between two samples.

    :param sample1: The first sample as a numpy array.
    :param sample2: The second sample as a numpy array.
    :param weights_sample1: The weights associated with the elements in sample1 as a numpy array.
    :param weights_sample2: The weights associated with the elements in sample2 as a numpy array.
    :param p_norm: The p-norm to be used in the computation of the EMD. Default is 1.

    :return: The Earth Mover&#39;s Distance between the two samples.
    &#34;&#34;&#34;
    return ot.emd2_1d(sample1, sample2, a=weights_sample1, b=weights_sample2,
                      metric=&#34;minkowski&#34;, p=p_norm)  # direct computation of OT loss</code></pre>
</details>
</dd>
<dt id="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_optimal_transport"><code class="name flex">
<span>def <span class="ident">wasserstein_optimal_transport</span></span>(<span>samples1: numpy.ndarray, samples2: numpy.ndarray, weights1: numpy.ndarray = None, weights2: numpy.ndarray = None, p_norm: int = 1, parallel_computing: bool = False, verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>The function <code><a title="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_optimal_transport" href="#BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_optimal_transport">wasserstein_optimal_transport()</a></code> computes the Wasserstein Optimal Transport distance
between two sets of samples.</p>
<p>:param samples1: An array of shape (n_samples, n_distributions) representing the first set of
samples. Each row corresponds to a sample, and each column corresponds to a distribution
:type samples1: np.ndarray
:param samples2: Array of shape (m_samples, n_distributions) representing the second set of samples
:type samples2: np.ndarray
:param weights1: Array of shape (n_samples,) representing the weights for each sample in samples1.
These weights determine the importance of each sample in the computation of the Wasserstein Optimal
Transport distance. If not provided, equal weights are assigned to each sample
:type weights1: np.ndarray
:param weights2: The <code>weights2</code> parameter is an optional array of shape (m_samples,) representing
the weights for each sample in <code>samples2</code>. These weights are used to compute the Wasserstein Optimal
Transport distance between the two sets of samples. If <code>weights2</code> is not provided, it defaults to an
:type weights2: np.ndarray
:param p_norm: The parameter <code>p_norm</code> is the p-norm to be used in the computation of the Wasserstein
Optimal Transport distance. It determines the distance metric used to measure the discrepancy
between the distributions. The default value is 1, which corresponds to the Earth Mover's distance.
Other common choices, defaults to 1
:type p_norm: int (optional)
:param parallel_computing: The <code>parallel_computing</code> parameter is a boolean flag indicating whether
to use parallel computation or not. If set to <code>True</code>, the function will use parallel computation to
speed up the computation of the Wasserstein Optimal Transport distance. If set to <code>False</code>, the
function will use a single thread, defaults to False
:type parallel_computing: bool (optional)
:param verbose: The <code>verbose</code> parameter is a boolean flag indicating whether to display progress
information during the computation. If set to <code>True</code>, it will display progress information; if set
to <code>False</code>, it will not display any progress information, defaults to False
:type verbose: bool (optional)
:return: an array of shape (n_distributions,) containing the Wasserstein Optimal Transport distance
for each distribution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wasserstein_optimal_transport(samples1: np.ndarray,  # n_samples x n_distributions

                                  samples2: np.ndarray,  # m_samples x n_distributions
                                  weights1: np.ndarray = None,  # weight per sample
                                  weights2: np.ndarray = None,  # weight per sample
                                  p_norm: int = 1,  # p-norm
                                  parallel_computing: bool = False,  # parallel computation
                                  verbose: bool = False):  # verbose
    &#34;&#34;&#34;
    The function `wasserstein_optimal_transport` computes the Wasserstein Optimal Transport distance
    between two sets of samples.

    :param samples1: An array of shape (n_samples, n_distributions) representing the first set of
    samples. Each row corresponds to a sample, and each column corresponds to a distribution
    :type samples1: np.ndarray
    :param samples2: Array of shape (m_samples, n_distributions) representing the second set of samples
    :type samples2: np.ndarray
    :param weights1: Array of shape (n_samples,) representing the weights for each sample in samples1.
    These weights determine the importance of each sample in the computation of the Wasserstein Optimal
    Transport distance. If not provided, equal weights are assigned to each sample
    :type weights1: np.ndarray
    :param weights2: The `weights2` parameter is an optional array of shape (m_samples,) representing
    the weights for each sample in `samples2`. These weights are used to compute the Wasserstein Optimal
    Transport distance between the two sets of samples. If `weights2` is not provided, it defaults to an
    :type weights2: np.ndarray
    :param p_norm: The parameter `p_norm` is the p-norm to be used in the computation of the Wasserstein
    Optimal Transport distance. It determines the distance metric used to measure the discrepancy
    between the distributions. The default value is 1, which corresponds to the Earth Mover&#39;s distance.
    Other common choices, defaults to 1
    :type p_norm: int (optional)
    :param parallel_computing: The `parallel_computing` parameter is a boolean flag indicating whether
    to use parallel computation or not. If set to `True`, the function will use parallel computation to
    speed up the computation of the Wasserstein Optimal Transport distance. If set to `False`, the
    function will use a single thread, defaults to False
    :type parallel_computing: bool (optional)
    :param verbose: The `verbose` parameter is a boolean flag indicating whether to display progress
    information during the computation. If set to `True`, it will display progress information; if set
    to `False`, it will not display any progress information, defaults to False
    :type verbose: bool (optional)
    :return: an array of shape (n_distributions,) containing the Wasserstein Optimal Transport distance
    for each distribution.
    &#34;&#34;&#34;

    _, num_distributions = samples1.shape
    # parallel execution of statistical test
    if weights1 is None:
        weights1 = np.ones(samples1.shape[0]) / samples1.shape[0]
    if weights2 is None:
        weights2 = np.ones(samples2.shape[0]) / samples2.shape[0]

    if parallel_computing:
        n_jobs = -2
    else:
        n_jobs = 1

    wd = joblib.Parallel(n_jobs=n_jobs, verbose=0)(
        joblib.delayed(earth_mover_distance)(samples1[:, i], samples2[:, i],
                                             weights1, weights2, p_norm) for i in tqdm(range(0, num_distributions), disable=not verbose))

    return np.asarray(wd)</code></pre>
</details>
</dd>
<dt id="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_p1_univariate_gaussian_gaussian"><code class="name flex">
<span>def <span class="ident">wasserstein_p1_univariate_gaussian_gaussian</span></span>(<span>mean1: Union[float, numpy.ndarray], var1: Union[float, numpy.ndarray], mean2: Union[float, numpy.ndarray], var2: Union[float, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>The function calculates the 1-Wasserstein distance between two univariate Gaussian distributions.</p>
<p>:param mean1: The mean of the first Gaussian distribution
:type mean1: typing.Union[float, np.ndarray]
:param var1: The variable <code>var1</code> represents the variance of the first Gaussian distribution
:type var1: typing.Union[float, np.ndarray]
:param mean2: The parameter <code>mean2</code> represents the mean of the second Gaussian distribution
:type mean2: typing.Union[float, np.ndarray]
:param var2: The parameter <code>var2</code> represents the variance of the second Gaussian distribution
:type var2: typing.Union[float, np.ndarray]
:return: the 1-Wasserstein distance between two univariate Gaussian distributions.
:rtype: np.ndarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wasserstein_p1_univariate_gaussian_gaussian(mean1: typing.Union[float, np.ndarray], var1: typing.Union[float, np.ndarray],
                                                mean2: typing.Union[float, np.ndarray], var2: typing.Union[float, np.ndarray],):
    &#34;&#34;&#34;
    The function calculates the 1-Wasserstein distance between two univariate Gaussian distributions.

    :param mean1: The mean of the first Gaussian distribution
    :type mean1: typing.Union[float, np.ndarray]
    :param var1: The variable `var1` represents the variance of the first Gaussian distribution
    :type var1: typing.Union[float, np.ndarray]
    :param mean2: The parameter `mean2` represents the mean of the second Gaussian distribution
    :type mean2: typing.Union[float, np.ndarray]
    :param var2: The parameter `var2` represents the variance of the second Gaussian distribution
    :type var2: typing.Union[float, np.ndarray]
    :return: the 1-Wasserstein distance between two univariate Gaussian distributions.
    :rtype: np.ndarray
    &#34;&#34;&#34;
    # calculate 1-wasserstein distance between two gaussians
    # On the 1-Wasserstein Distance between Location-Scale Distributions and the Effect of Differential Privacy
    # Saurab Chhachhi, Fei Teng
    # https://doi.org/10.48550/arXiv.2304.14869 equation (34)

    # flatten arrays
    mean1 = np.ravel(mean1)
    mean2 = np.ravel(mean2)
    var1 = np.ravel(var1)
    var2 = np.ravel(var2)

    mean_y = mean1 - mean2
    cov_y = np.square(np.sqrt(var1) - np.sqrt(var2))
    mean_y_abs = np.abs(mean_y)
    std_y_abs = np.abs(np.sqrt(cov_y))
    factor1 = mean_y_abs

    factor2 = np.empty_like(mean_y_abs)
    factor4 = np.empty_like(mean_y_abs)

    where_std_y_zero = std_y_abs == 0
    non_zero = np.logical_not(where_std_y_zero)

    if np.sum(non_zero) &gt; 0:
        factor2[non_zero] = 1 - 2 * \
            scipy.stats.norm.cdf(-mean_y_abs[non_zero] / std_y_abs[non_zero])
        factor4[non_zero] = np.exp(-np.square(mean_y_abs) / (2 * cov_y[non_zero]))

    if np.sum(where_std_y_zero) &gt; 0:
        # limit of factor1 for cov_y -&gt; 0 is 1; see paper
        factor2[where_std_y_zero] = 1

        # limit of factor4 for cov_y -&gt; 0 is 1; see paper
        factor4[where_std_y_zero] = np.ones_like(factor4[where_std_y_zero])

    factor3 = std_y_abs * np.sqrt(2 / np.pi)

    term1 = factor1 * factor2
    term2 = factor3 * factor4

    return term1 + term2</code></pre>
</details>
</dd>
<dt id="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_univariate_gaussian_dirac_mixture"><code class="name flex">
<span>def <span class="ident">wasserstein_univariate_gaussian_dirac_mixture</span></span>(<span>samples: numpy.ndarray, mean: float, var: float, p_norm: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the Wasserstein distance between a Gaussian distribution and a Dirac mixture.
Use only to calculate between one Gaussian and one Dirac mixture.
To calculate multiple distances, use <code>wasserstein_p1_univariate_gaussian_dirac_multiple_distances</code>.</p>
<p>:param samples: The samples from the Dirac mixture.
:type samples: numpy.ndarray (n_samples, 1)
:param mean: The mean of the Gaussian distribution.
:type mean: float
:param var: The variance of the Gaussian distribution.
:type var: float
:param p_norm: The p-norm used in the Wasserstein distance calculation. Default is 1.
:type p_norm: int, optional</p>
<p>:return: The Wasserstein distance between the Gaussian distribution and the Dirac mixture.
:rtype: float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wasserstein_univariate_gaussian_dirac_mixture(samples: np.ndarray, mean: float, var: float, p_norm: int = 1):
    &#34;&#34;&#34;
    Calculate the Wasserstein distance between a Gaussian distribution and a Dirac mixture.
    Use only to calculate between one Gaussian and one Dirac mixture.
    To calculate multiple distances, use `wasserstein_p1_univariate_gaussian_dirac_multiple_distances`.

    :param samples: The samples from the Dirac mixture.
    :type samples: numpy.ndarray (n_samples, 1)
    :param mean: The mean of the Gaussian distribution.
    :type mean: float
    :param var: The variance of the Gaussian distribution.
    :type var: float
    :param p_norm: The p-norm used in the Wasserstein distance calculation. Default is 1.
    :type p_norm: int, optional

    :return: The Wasserstein distance between the Gaussian distribution and the Dirac mixture.
    :rtype: float
    &#34;&#34;&#34;
    sorted_samples = np.sort(samples)
    num_samples = sorted_samples.shape[0]
    empirical_cdf = (np.arange(num_samples)+1) / (num_samples)
    mid_points_ecdf = empirical_cdf - 1/(2 * num_samples)
    gaussian_sample_positions = scipy.stats.norm.ppf(mid_points_ecdf, loc=mean, scale=np.sqrt(var))
    norm = np.power(np.abs(gaussian_sample_positions - sorted_samples), p_norm)
    wasserstein_dist = np.mean(norm)
    return wasserstein_dist</code></pre>
</details>
</dd>
<dt id="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_univariate_gaussian_dirac_multiple_distances"><code class="name flex">
<span>def <span class="ident">wasserstein_univariate_gaussian_dirac_multiple_distances</span></span>(<span>samples: numpy.ndarray, mean1: numpy.ndarray, var1: numpy.ndarray, p_norm: int = 1, parallel_computing: bool = False, verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>The function calculates the Wasserstein distance between n=<code>num_distributions</code> univariate Gaussian and Dirac mixture
distributions.</p>
<p>:param samples: The <code>samples</code> parameter is a numpy array containing the samples from a univariate
distribution. Each row of the array represents a different sample, and each column
represents a different distribution. The shape of the array should be (n_samples, num_distributions),
:type samples: np.ndarray
:param mean1: The parameter <code>mean1</code> represents the mean of a univariate Gaussian distribution
:type mean1: np.ndarray
:param var1: The parameter <code>var1</code> represents the variance of a univariate Gaussian distribution
:type var1: np.ndarray
:param verbose: The <code>verbose</code> parameter is a boolean flag that determines whether or not to display
progress information during the computation. If <code>verbose</code> is set to <code>True</code>, progress information
will be displayed. If <code>verbose</code> is set to <code>False</code>, progress information will be hidden, defaults to
False
:type verbose: bool (optional)
:return: an array of Wasserstein distances between the given samples and the ground truth
distribution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wasserstein_univariate_gaussian_dirac_multiple_distances(samples: np.ndarray,
                                                             mean1: np.ndarray, var1: np.ndarray,
                                                             p_norm: int = 1,
                                                             parallel_computing: bool = False,
                                                             verbose: bool = False):
    &#34;&#34;&#34;
    The function calculates the Wasserstein distance between n=`num_distributions` univariate Gaussian and Dirac mixture
    distributions.

    :param samples: The `samples` parameter is a numpy array containing the samples from a univariate
    distribution. Each row of the array represents a different sample, and each column
    represents a different distribution. The shape of the array should be (n_samples, num_distributions),
    :type samples: np.ndarray
    :param mean1: The parameter `mean1` represents the mean of a univariate Gaussian distribution
    :type mean1: np.ndarray
    :param var1: The parameter `var1` represents the variance of a univariate Gaussian distribution
    :type var1: np.ndarray
    :param verbose: The `verbose` parameter is a boolean flag that determines whether or not to display
    progress information during the computation. If `verbose` is set to `True`, progress information
    will be displayed. If `verbose` is set to `False`, progress information will be hidden, defaults to
    False
    :type verbose: bool (optional)
    :return: an array of Wasserstein distances between the given samples and the ground truth
    distribution.
    &#34;&#34;&#34;
    _, num_distributions = samples.shape
    wd_1 = np.empty((num_distributions,))
    # for i in tqdm(range(0, num_distributions), desc=&#34;W1(Gaussian, Dirac mixture)&#34;, disable=not verbose):
    #     wd_1[i] = gaussian_dirac_mixture_wasserstein(
    #         samples=samples[:, i], mean=mean1[i], var=var1[i], p_norm=p_norm)

    if parallel_computing:
        n_jobs = -2
    else:
        n_jobs = 1

    wd_1 = joblib.Parallel(n_jobs=n_jobs, verbose=0)(
        joblib.delayed(
            wasserstein_univariate_gaussian_dirac_mixture)(samples[:, i],
                                                           mean1[i],
                                                           var1[i],
                                                           p_norm) for i in tqdm(range(0, num_distributions), disable=not verbose))
    wd_1 = np.asarray(wd_1)
    return wd_1</code></pre>
</details>
</dd>
<dt id="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_univariate_wrapper"><code class="name flex">
<span>def <span class="ident">wasserstein_univariate_wrapper</span></span>(<span>pred_a: Union[numpy.ndarray, <a title="BNN_trust_regions.bnn_trust_regions.gaussian.UnivariateGaussian" href="gaussian.html#BNN_trust_regions.bnn_trust_regions.gaussian.UnivariateGaussian">UnivariateGaussian</a>], pred_b: Union[numpy.ndarray, <a title="BNN_trust_regions.bnn_trust_regions.gaussian.UnivariateGaussian" href="gaussian.html#BNN_trust_regions.bnn_trust_regions.gaussian.UnivariateGaussian">UnivariateGaussian</a>], p_norm: int = 1, parallel_computing: bool = False, verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>The function calculates the Wasserstein distance between two univariate distributions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wasserstein_univariate_wrapper(pred_a: typing.Union[np.ndarray, UnivariateGaussian],
                                   pred_b: typing.Union[np.ndarray, UnivariateGaussian],
                                   p_norm: int = 1,
                                   parallel_computing: bool = False,
                                   verbose: bool = False):
    &#34;&#34;&#34;
    The function calculates the Wasserstein distance between two univariate distributions.

    &#34;&#34;&#34;

    # distance between two univariate gaussians
    if isinstance(pred_a, UnivariateGaussian) and isinstance(pred_b, UnivariateGaussian):
        # this is the analytical solution for the 1-Wasserstein distance between two univariate Gaussians
        if p_norm == 1:
            return wasserstein_p1_univariate_gaussian_gaussian(pred_a.mean, pred_a.var, pred_b.mean, pred_b.var)

        if p_norm == 2:
            raise NotImplementedError(
                &#34;The 2-Wasserstein distance between two univariate Gaussians is not implemented.&#34;)

        raise ValueError(
            &#34;The p-norm must be either 1 or 2 for the Wasserstein distance between two univariate Gaussians.&#34;)

    # distance between a univariate gaussian and a dirac mixture
    if isinstance(pred_a, UnivariateGaussian) and isinstance(pred_b, np.ndarray):
        return wasserstein_univariate_gaussian_dirac_multiple_distances(
            pred_b, pred_a.mean, pred_a.var, p_norm=p_norm, parallel_computing=parallel_computing, verbose=verbose)

    # distance between a dirac mixture and a univariate gaussian
    if isinstance(pred_a, np.ndarray) and isinstance(pred_b, UnivariateGaussian):
        return wasserstein_univariate_gaussian_dirac_multiple_distances(
            pred_a, pred_b.mean, pred_b.var, p_norm=p_norm, parallel_computing=parallel_computing, verbose=verbose)

    # distance between two dirac mixtures
    if isinstance(pred_a, np.ndarray) and isinstance(pred_b, np.ndarray):
        return wasserstein_optimal_transport(pred_a, pred_b, p_norm=p_norm, parallel_computing=parallel_computing, verbose=verbose)

    raise ValueError(
        &#34;The input parameters must be either a numpy array or an instance of the Gaussian class.&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.WassersteinDistance"><code class="flex name class">
<span>class <span class="ident">WassersteinDistance</span></span>
<span>(</span><span>p_norm: int = 1, parallel_computing: bool = False, verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="the-class-wassersteindistance-calculates-the-wasserstein-distance-between-two-sets-of-predictions">The class WassersteinDistance calculates the Wasserstein distance between two sets of predictions</h1>
<h1 id="using-the-specified-p-norm-and-parallel-computing-options">using the specified p-norm and parallel computing options.</h1>
<p>The function initializes an object with two sets of predictions, a p-norm value, a flag for
parallel computing, and a flag for verbosity.</p>
<p>:param predictions_a: The parameter <code>predictions_a</code> is used to pass the predictions for dataset
A. It can be either a numpy array or an instance of the <code>UnivariateGaussian</code> class
:type predictions_a: typing.Union[np.ndarray, UnivariateGaussian]
:param predictions_b: The <code>predictions_b</code> parameter is used to pass the predictions for the
second set of data. It can be either a numpy array or an instance of the <code>UnivariateGaussian</code>
class
:type predictions_b: typing.Union[np.ndarray, UnivariateGaussian]
:param p_norm: The p_norm parameter is an integer that specifies the norm to be used for
calculating the distance between the predictions. It is used in the calculation of the distance
between two predictions, where the distance is calculated as the p-norm of the difference
between the two predictions. The p-norm is a general, defaults to 1
:type p_norm: int (optional)
:param parallel_computing: The <code>parallel_computing</code> parameter is a boolean flag that indicates
whether or not to use parallel computing for the calculations. If set to <code>True</code>, the
calculations will be performed in parallel, which can potentially speed up the computation time.
If set to <code>False</code>, the calculations will be performed sequentially, defaults to False
:type parallel_computing: bool (optional)
:param verbose: The <code>verbose</code> parameter is a boolean flag that determines whether or not to
print additional information during the execution of the code. If <code>verbose</code> is set to <code>True</code>,
then additional information will be printed. If <code>verbose</code> is set to <code>False</code>, then no additional
information will be printed, defaults to False
:type verbose: bool (optional)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WassersteinDistance:
    &#34;&#34;&#34;
    # The class WassersteinDistance calculates the Wasserstein distance between two sets of predictions
    # using the specified p-norm and parallel computing options.
    &#34;&#34;&#34;

    def __init__(self,
                 p_norm: int = 1,
                 parallel_computing: bool = False,
                 verbose: bool = False):
        &#34;&#34;&#34;
        The function initializes an object with two sets of predictions, a p-norm value, a flag for
        parallel computing, and a flag for verbosity.

        :param predictions_a: The parameter `predictions_a` is used to pass the predictions for dataset
        A. It can be either a numpy array or an instance of the `UnivariateGaussian` class
        :type predictions_a: typing.Union[np.ndarray, UnivariateGaussian]
        :param predictions_b: The `predictions_b` parameter is used to pass the predictions for the
        second set of data. It can be either a numpy array or an instance of the `UnivariateGaussian`
        class
        :type predictions_b: typing.Union[np.ndarray, UnivariateGaussian]
        :param p_norm: The p_norm parameter is an integer that specifies the norm to be used for
        calculating the distance between the predictions. It is used in the calculation of the distance
        between two predictions, where the distance is calculated as the p-norm of the difference
        between the two predictions. The p-norm is a general, defaults to 1
        :type p_norm: int (optional)
        :param parallel_computing: The `parallel_computing` parameter is a boolean flag that indicates
        whether or not to use parallel computing for the calculations. If set to `True`, the
        calculations will be performed in parallel, which can potentially speed up the computation time.
        If set to `False`, the calculations will be performed sequentially, defaults to False
        :type parallel_computing: bool (optional)
        :param verbose: The `verbose` parameter is a boolean flag that determines whether or not to
        print additional information during the execution of the code. If `verbose` is set to `True`,
        then additional information will be printed. If `verbose` is set to `False`, then no additional
        information will be printed, defaults to False
        :type verbose: bool (optional)
        &#34;&#34;&#34;
        self.p_norm = p_norm
        self.parallel_computing = parallel_computing
        self.verbose = verbose

    def calc_wasserstein_distance(self, predictions_a: typing.Union[np.ndarray, UnivariateGaussian],
                                  predictions_b: typing.Union[np.ndarray, UnivariateGaussian],):
        &#34;&#34;&#34;
        The function calculates the Wasserstein distance between two sets of predictions.
        :return: the result of the `wasserstein_univariate_wrapper` function, which calculates the
        Wasserstein distance between `self.predictions_a` and `self.predictions_b`.
        &#34;&#34;&#34;
        return wasserstein_univariate_wrapper(predictions_a, predictions_b,
                                              p_norm=self.p_norm,
                                              parallel_computing=self.parallel_computing,
                                              verbose=self.verbose)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.WassersteinDistance.calc_wasserstein_distance"><code class="name flex">
<span>def <span class="ident">calc_wasserstein_distance</span></span>(<span>self, predictions_a: Union[numpy.ndarray, <a title="BNN_trust_regions.bnn_trust_regions.gaussian.UnivariateGaussian" href="gaussian.html#BNN_trust_regions.bnn_trust_regions.gaussian.UnivariateGaussian">UnivariateGaussian</a>], predictions_b: Union[numpy.ndarray, <a title="BNN_trust_regions.bnn_trust_regions.gaussian.UnivariateGaussian" href="gaussian.html#BNN_trust_regions.bnn_trust_regions.gaussian.UnivariateGaussian">UnivariateGaussian</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>The function calculates the Wasserstein distance between two sets of predictions.
:return: the result of the <code><a title="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_univariate_wrapper" href="#BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_univariate_wrapper">wasserstein_univariate_wrapper()</a></code> function, which calculates the
Wasserstein distance between <code>self.predictions_a</code> and <code>self.predictions_b</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_wasserstein_distance(self, predictions_a: typing.Union[np.ndarray, UnivariateGaussian],
                              predictions_b: typing.Union[np.ndarray, UnivariateGaussian],):
    &#34;&#34;&#34;
    The function calculates the Wasserstein distance between two sets of predictions.
    :return: the result of the `wasserstein_univariate_wrapper` function, which calculates the
    Wasserstein distance between `self.predictions_a` and `self.predictions_b`.
    &#34;&#34;&#34;
    return wasserstein_univariate_wrapper(predictions_a, predictions_b,
                                          p_norm=self.p_norm,
                                          parallel_computing=self.parallel_computing,
                                          verbose=self.verbose)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="BNN_trust_regions.bnn_trust_regions" href="index.html">BNN_trust_regions.bnn_trust_regions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.earth_mover_distance" href="#BNN_trust_regions.bnn_trust_regions.wasserstein_dist.earth_mover_distance">earth_mover_distance</a></code></li>
<li><code><a title="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_optimal_transport" href="#BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_optimal_transport">wasserstein_optimal_transport</a></code></li>
<li><code><a title="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_p1_univariate_gaussian_gaussian" href="#BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_p1_univariate_gaussian_gaussian">wasserstein_p1_univariate_gaussian_gaussian</a></code></li>
<li><code><a title="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_univariate_gaussian_dirac_mixture" href="#BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_univariate_gaussian_dirac_mixture">wasserstein_univariate_gaussian_dirac_mixture</a></code></li>
<li><code><a title="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_univariate_gaussian_dirac_multiple_distances" href="#BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_univariate_gaussian_dirac_multiple_distances">wasserstein_univariate_gaussian_dirac_multiple_distances</a></code></li>
<li><code><a title="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_univariate_wrapper" href="#BNN_trust_regions.bnn_trust_regions.wasserstein_dist.wasserstein_univariate_wrapper">wasserstein_univariate_wrapper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.WassersteinDistance" href="#BNN_trust_regions.bnn_trust_regions.wasserstein_dist.WassersteinDistance">WassersteinDistance</a></code></h4>
<ul class="">
<li><code><a title="BNN_trust_regions.bnn_trust_regions.wasserstein_dist.WassersteinDistance.calc_wasserstein_distance" href="#BNN_trust_regions.bnn_trust_regions.wasserstein_dist.WassersteinDistance.calc_wasserstein_distance">calc_wasserstein_distance</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>